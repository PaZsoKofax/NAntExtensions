<?xml version="1.0"?>
<project name="SignEEBinaries" default="sign.binaries" xmlns="http://nant.sf.net/release/0.92/nant.xsd">
	<include buildfile="global.properties.build" />

	<script language="C#" prefix="custom" >
  <references>
    <include name="System.dll" />
    <include name="${nant::get-base-directory()}/NAnt.Contrib.Tasks.dll" />
  </references>
  <imports>
    <import namespace="System.Diagnostics" />
    <import namespace="System.ComponentModel" />
    <import namespace="System.Threading" />
    <import namespace="NAnt.Core.Types" />
  </imports>
  <code>
    <![CDATA[
[Function("is-signed")]
public static bool IsSigned(string filePath)
{
	try
	{
		System.Security.Cryptography.X509Certificates.X509Certificate certificate = new System.Security.Cryptography.X509Certificates.X509Certificate(filePath);
		// An exception would be thrown if the file was not signed
		return true;
	}
	catch (Exception e) { }
	return false;
}

[TaskName("sign")]
public class SignTask : Task 
{
	#region Public Instance Properties
	[TaskAttribute("filename")]
	public string FileName { get; set; }
  
	[TaskAttribute("description")]
  [StringValidatorAttribute(AllowEmpty=false)]
	public string Description { get; set; }

  [TaskAttribute("pagehashes")]
  [BooleanValidator()]
  public bool PageHashes { get; set; }
  
  [TaskAttribute("retries")]
  [Int32Validator(MinValue=0)]
  public int Retries { get; set; }
  
	[TaskAttribute("signtoolpath")]
  [StringValidatorAttribute(AllowEmpty=false)]
	public string SignToolPath { get; set; }
  
  [TaskAttribute("additionalcertificate")]
  [StringValidatorAttribute(AllowEmpty=false)]
	public string AdditionalCertificate { get; set; }
  
  [TaskAttribute("subjectname")]
  [StringValidatorAttribute(AllowEmpty=false)]
	public string SubjectName { get; set; }
  
  [TaskAttribute("url")]
  [StringValidatorAttribute(AllowEmpty=false)]
	public string URL { get; set; }
  
  [TaskAttribute("timestampurl")]
  [StringValidatorAttribute(AllowEmpty=false)]
	public string TimestampURL { get; set; }
  
  [BuildElement("items")]
  public FileSet Items { get; set; }
	#endregion Public Instance Properties
  
  #region Default Constructor
  public SignTask()
  {
    Retries = 2;
    SignToolPath = @"C:\Program Files (x86)\Microsoft SDKs\Windows\v7.0A\Bin";
    AdditionalCertificate = string.Empty;
    SubjectName = @"MyCompany";
    URL = @"http://www.mycompany.com";
    TimestampURL = @"http://timestamp.verisign.com/scripts/timstamp.dll";
    PageHashes = false;
  }
  #endregion Default Constructor
  
  #region Protected Instance Methods
  protected void SignFiles(string files)
  {
		Process myProcess = new Process();
		try
		{
      // Build the argument string
      StringBuilder args = new StringBuilder(@"sign /a ");
      args.Append(@"/n """ + SubjectName + @""" ");
      args.Append(@"/du """ + URL + @""" ");
      args.Append(@"/t """ + TimestampURL + @""" ");
      // Optional arguments
      if( Verbose ) args.Append(@"/v ");
      if( PageHashes ) args.Append(@"/ph /ac """ + AdditionalCertificate + @""" ");
      if( !String.IsNullOrEmpty(Description) ) args.Append(@"/d """ + Description + @""" ");
      // File(s) to be signed
      args.Append(files.ToString());
      
      if( Verbose )
        Log(Level.Info, "Args: " + args.ToString());
		
			myProcess.StartInfo.FileName = SignToolPath + @"\signtool.exe";
			myProcess.StartInfo.Arguments = args.ToString();
			myProcess.StartInfo.UseShellExecute = false;
			myProcess.StartInfo.RedirectStandardOutput = true;
      
      int exitCode = 1; // Do not assume success to enter for loop
      int maxAttempts = Retries + 1;
      for( int attempt = 1; attempt <= maxAttempts && exitCode != 0; attempt++ )
      {
        if( Verbose )
          Log(Level.Info, "Signing attempt {0}", attempt);
        if( Retries > 0 && attempt == maxAttempts )
        {
          Log(Level.Warning, "Last attempt. Sleeping for a few seconds to possibly let Verisign wake up.");
          Thread.Sleep(3000);
        }
        
			  myProcess.Start();
        myProcess.WaitForExit();
        
        // Read the standard output of the spawned process. 
        StreamReader myStreamReader = myProcess.StandardOutput;
        while(!myStreamReader.EndOfStream)
        {
			    Log(Level.Info, myStreamReader.ReadLine());
        }
        
        exitCode = myProcess.ExitCode;
        myProcess.Close();
      }
      
      // Check for errors
      if (exitCode == 2)
        throw new BuildException("Failed to communicate with timestamp server.", Location);
      else if (exitCode != 0)
        throw new BuildException("Failed to sign. Error " + exitCode, Location);
		}
    catch (Win32Exception e)
    {
      throw new BuildException("Unable to find signtool.exe in " + SignToolPath, Location, e);
    }  
  }
  #endregion Protected Instance Methods
    
	#region Override implementation of Task
	protected override void ExecuteTask() {
    // Validate the parameters
    if (string.IsNullOrEmpty(FileName) && (Items==null || Items.FileNames.Count==0))
      throw new BuildException("Must specify @filename or <items>.", Location);
    if (!string.IsNullOrEmpty(FileName) && Items!=null && Items.FileNames.Count>0)
      throw new BuildException("Cannot specify @filename and <items>.", Location);
    
    if (Verbose)
    {
      Log(Level.Info, "Description: {0}", Description);
      Log(Level.Info, "Page Hashes: {0}", PageHashes);
      Log(Level.Info, "Retries: {0}", Retries);
      Log(Level.Info, "SignTool Path: {0}", SignToolPath);
      Log(Level.Info, "Additional Certificate: {0}", AdditionalCertificate);
      Log(Level.Info, "Subject Name: {0}", SubjectName);
      Log(Level.Info, "Timestamp URL: {0}", TimestampURL);
      Log(Level.Info, "URL: {0}", URL);
		  Log(Level.Info, "FileName: {0}", FileName);
    }
    
    StringBuilder filenames = new StringBuilder();
    if (Items!=null)
    {
      // Construct the file list
      int count = 0;
      foreach (string file in Items.FileNames)
      {
        if (!IsSigned(file))
        {
          filenames.Append(@"""");
          filenames.Append(file);
          filenames.Append(@""" ");
          count++;
        }
        // Limit the number of files being signed in any single call to SignTool
        if (filenames.Length>1000)
        {
          SignFiles(filenames.ToString());
          filenames.Clear();
        }
      }
      // Sign any remaining files
      if (filenames.Length>0)
        SignFiles(filenames.ToString());
      Log(Level.Info, "Signed {0} files", count);
    } 
    else 
    {
      if (!IsSigned(FileName))
      {
        // A single file is to be signed
        filenames.Append(@"""");
        filenames.Append(FileName);
        filenames.Append(@""" ");
        SignFiles(filenames.ToString());
      }
      else
        Log(Level.Info, "Skipping {0}. It is already signed", FileName);
    }
	}
	#endregion Override implementation of Task
}
    ]]>
  </code>
	</script>		
	
  <!-- example -->  
	<!--<target name="sign" description="Signs files">
    <sign description="Your signing description here" pagehashes="true">
      <items>
        <include name="\out\**\**\*.exe" />
        <include name="\out\**\**\*.dll" />
      </items>
    </sign>
	</target>-->
</project>
